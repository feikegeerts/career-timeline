name: Deploy AWS Infrastructure

on:
  workflow_dispatch: # Allows manual triggering
  push:
    branches: [main]
    paths:
      - 'infrastructure/cloudformation/**'
      - 'data/careerEvents.json'
      - '.github/workflows/deploy-infrastructure.yml'

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Deploy CloudFormation stack
        id: deploy-stack
        run: |
          # Check if stack exists
          if aws cloudformation describe-stacks --stack-name career-timeline-api 2>&1 | grep -q "Stack with id career-timeline-api does not exist"; then
            echo "Creating new stack..."
            aws cloudformation create-stack \
              --stack-name career-timeline-api \
              --template-body file://infrastructure/cloudformation/career-timeline-api.yaml \
              --capabilities CAPABILITY_IAM \
              --parameters ParameterKey=CorsOrigin,ParameterValue=https://feikegeerts.nl
            
            # Wait for stack creation to complete
            aws cloudformation wait stack-create-complete --stack-name career-timeline-api
          else
            echo "Updating existing stack..."
            aws cloudformation update-stack \
              --stack-name career-timeline-api \
              --template-body file://infrastructure/cloudformation/career-timeline-api.yaml \
              --capabilities CAPABILITY_IAM \
              --parameters ParameterKey=CorsOrigin,ParameterValue=https://feikegeerts.nl || echo "No updates to be performed"
            
            # Only wait if an update was started
            if [ $? -eq 0 ]; then
              aws cloudformation wait stack-update-complete --stack-name career-timeline-api
            fi
          fi

          # Get stack outputs
          aws cloudformation describe-stacks \
            --stack-name career-timeline-api \
            --query "Stacks[0].Outputs" > stack-outputs.json

          # Extract needed values (non-sensitive)
          S3_BUCKET=$(cat stack-outputs.json | jq -r '.[] | select(.OutputKey=="S3BucketName") | .OutputValue')
          API_ENDPOINT=$(cat stack-outputs.json | jq -r '.[] | select(.OutputKey=="ApiEndpoint") | .OutputValue')

          # Extract API key (sensitive) and store as a GitHub secret
          API_KEY=$(cat stack-outputs.json | jq -r '.[] | select(.OutputKey=="ApiKey") | .OutputValue')
          if [ ! -z "$API_KEY" ]; then
            # Use GitHub CLI to set the secret securely, if CLI is available
            if command -v gh &> /dev/null && [ ! -z "${{ secrets.GITHUB_TOKEN }}" ]; then
              echo "::add-mask::$API_KEY"
              echo "Setting API_KEY as a repository secret... (output masked)"
              echo $API_KEY | gh secret set API_KEY --repo $GITHUB_REPOSITORY
              echo "API key has been stored as a repository secret"
            else
              # Mask the value in logs but warn that manual action is required
              echo "::add-mask::$API_KEY"
              echo "⚠️ IMPORTANT: Please manually add this API key as a GitHub secret named 'API_KEY'"
              echo "The key value is masked in the logs for security"
            fi
          fi

          # Set non-sensitive outputs for use in other steps
          echo "s3_bucket=$S3_BUCKET" >> $GITHUB_OUTPUT
          echo "api_endpoint=$API_ENDPOINT" >> $GITHUB_OUTPUT

      - name: Upload career data to S3
        run: |
          aws s3 cp data/careerEvents.json s3://${{ steps.deploy-stack.outputs.s3_bucket }}/careerEvents.json

      - name: Update API details safely
        run: |
          # Create or update .env.local file with API endpoint (non-sensitive)
          echo "VITE_API_URL=${{ steps.deploy-stack.outputs.api_endpoint }}" > .env.local

          # Use the API key from GitHub secrets if available, otherwise leave a placeholder
          if [ ! -z "${{ secrets.API_KEY }}" ]; then
            echo "VITE_API_KEY=${{ secrets.API_KEY }}" >> .env.local
            echo "Added API key from repository secrets to .env.local"
          else
            echo "VITE_API_KEY=PLACEHOLDER_REPLACE_WITH_ACTUAL_KEY" >> .env.local
            echo "⚠️ WARNING: Please replace the placeholder API key in .env.local with the actual key"
          fi

          # Ensure .env.local is in .gitignore to prevent accidental commits
          if ! grep -q ".env.local" .gitignore 2>/dev/null; then
            echo ".env.local" >> .gitignore
            echo "Added .env.local to .gitignore for security"
          fi

      - name: Output information
        run: |
          echo "✅ Infrastructure deployment complete!"
          echo "🔗 API Endpoint: ${{ steps.deploy-stack.outputs.api_endpoint }}"
          echo "🗄️ S3 Bucket: ${{ steps.deploy-stack.outputs.s3_bucket }}"
          echo "🛡️ Security note: API Key has been masked in logs and stored securely"
